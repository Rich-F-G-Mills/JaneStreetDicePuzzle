---
title: "Jane Street Dice Puzzle"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float:
      smooth_scroll: true
    keep_md: yes
    pandoc_args: ["--lua-filter=ASSETS/colour-text.lua"]
author: "Richard Mills"
date: "`r Sys.Date()`"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo=FALSE)
knitr::opts_chunk$set(include=FALSE)

Nmax <- 100L
Dmax <- 20L
```

```{cat, engine.opts = list(file = "ASSETS/colour-text.lua")}
Span = function(el)
  fore_colour = el.attributes['foreground']
  back_colour = el.attributes['background']
  
  -- if no colours specified, return unchange
  if fore_colour == nil and back_colour == nil then return el end

  -- transform to <span style="..."></span>
  if FORMAT:match 'html' then
    style_str = ""
  
    -- remove color attributes
    el.attributes['foreground'] = nil
    el.attributes['background'] = nil
    
    if fore_colour ~= nil then
      style_str = style_str .. 'color:' .. fore_colour .. ';'
    end
    
    if back_colour ~= nil then
      style_str = style_str .. 'background-color:' .. back_colour .. ';'
    end
    
    -- use style attribute instead
    el.attributes['style'] = style_str
    
    -- return full span element
    return el
  else
    -- for other format return unchanged
    return el
  end
end
```

```{r loadLibraries}
library (ggplot2, warn.conflicts = FALSE)
library (glue, warn.conflicts = FALSE)
library (rlang, warn.conflicts = FALSE)
```

```{r loadVariants}
source('SCRIPTS/PART_1.R', local = knitr::knit_global())
source('SCRIPTS/PART_2.R', local = knitr::knit_global())
source('SCRIPTS/VISUALS.R', local = knitr::knit_global())
```

```{r registerLocalChunkHook}
knitr::opts_hooks$set(
  local =
    function (options) {
      options$code <-
        paste('local({\n', glue::glue_collapse(options$code, sep = '\n'), '\n})')
      
      options
    }
)
```

```{css include = TRUE}
h2 {
  text-decoration: underline;
}

p:has(+ ul) {
  margin-bottom: 0;
}
  
#TOC > ul > li {
  font-weight: bold
}
```

## Introduction

The purpose of this note is to show proposed solutions to the first two Jane Street dice puzzles proposed within the following [YouTube video](https://www.youtube.com/watch?v=NT_I1MjckaU&t=251s).

## First Variant

The following rules apply:

-   There is a `r Dmax`-sided die.
-   There are `r Nmax` turns.
-   At each turn, the player can choose to either:
    -   "Take" (ie. bank) the value as currently shown on the die.
    -   Re-roll the dice, but without any pay-off.
-   The die initially shows a value of 1.

For example, the player could elect to repeatedly take the opening value of 1 for all `r Nmax` turns, giving a final banked value of `r Nmax`.

### Possible Solution (Toy Example)

As a simplified toy example, instead assume we have a 4-sided die over 6 turns.

* Each node (ie. circle) represents a decision-point.
* Those with a [**red**]{foreground="red"} and [**blue**]{foreground="blue"} outline reflect those nodes where the optimal decision is to roll and take respectively.
* This is based on the expected value of nodes for the following turn.
* The expected future gain from such a decision is shown by the top and bottom numbers within each node; where both scores are the same, a take is prioritised.
* The extent of the [**fill**]{background="lightblue"} within each node shows the probability of the player reaching that node, within a given turn.
* For those nodes where the player should <u>**take**</u> the current die value, that value is maintained for the next turn as represented by the **thick black** horizontal lines. We note that all such nodes are absorbing states.
* Whereas, for those where the player should <u>**roll**</u>, there is an equal chance of landing on any die value for the next turn.
* At any given node, it is assumed that the player will always take the action that leads to the largest (expected) increase in pay-off.

```{r part1ToyExample, local = TRUE, results = 'asis', include = TRUE}
exampleResults <-
  fnPartIResults(Dmax = 4L, Nmax = 6L)

margin <-
  list(X = 50.0, Y = 100.0)

radius <- 17.0

style <-
  local({
    nodestyle <-
      htmltools::css(
        `stroke-width` = '2px',
        fill = 'white'
      )
    
    textStyle <-
      htmltools::css(
        `text-anchor` = 'middle',
        `alignment-baseline` = 'middle'
      )
    
    shiny::tags$style(
      glue::glue(
        'circle {<nodestyle>} text {<textStyle>}',
        .open = '<',
        .close = '>'
      )
    )
  })

nodes <-
  exampleResults$OUTCOMES |>
  dplyr::mutate(
    STRATEGY = dplyr::if_else(TAKE, 'TAKE', 'ROLL'),
    .keep = 'unused'
  ) |>
  tidyr::pivot_wider(
    names_from = STRATEGY,
    values_from = VALUE,
    names_prefix = 'VALUE_'
  ) |>
  dplyr::left_join(
    exampleResults$STRATEGY |>
      dplyr::select(N, D, TAKE),
    by = c('N', 'D')
  ) |>
  dplyr::left_join(
    exampleResults$CUMULATIVE_PROBS |>
      dplyr::count(N, D, wt = PROB, name = 'PROB'),
    by = c('N', 'D')
  ) |>
  dplyr::mutate(
    CX = 2.0 * margin$X + N * 75.0,
    CY = margin$Y + (D - 1.0) * 55.0,
    PROB_Y = CY - (radius - 1.0) + (2.0 * (radius - 1.0) * (1.0 - PROB))
  ) |>
  dplyr::rowwise() |>
  dplyr::mutate(
    NODE =
      list(
        shiny::tags$circle(
          cx = CX,
          cy = CY,
          r = radius,
          stroke =
            dplyr::if_else(TAKE, 'blue', 'red')
        )
      ),
    PROB_FILL =
      list(
        shiny::tags$rect(
          x = CX - (radius - 1.0),
          y = PROB_Y,
          width = 2.0 * (radius - 1.0),
          height = 2.0 * (radius - 1.0) * PROB,
          fill = 'lightblue',
          `clip-path` =
            glue::glue('circle({radius-1}px at 50% {CY - PROB_Y}px)')
        )
      ),
    VALUE_ROLL =
      list(
        shiny::tags$text(
          scales::number(VALUE_ROLL, accuracy = 0.1),
          `font-size` = '75%',
          x = CX,
          y = CY - 7.5
        )
      ),
    VALUE_TAKE =
      list(
        shiny::tags$text(
          scales::number(VALUE_TAKE, accuracy = 0.1),
          `font-size` = '75%',
          x = CX,
          y = CY + 7.5
        )
      )
  ) |>
  dplyr::ungroup()

lines <-
  nodes |>
  dplyr::inner_join(
    nodes |>
      dplyr::transmute(
        NEXT_N = N,
        NEXT_D = D,
        N = NEXT_N - 1L,
        NEXT_CX = CX,
        NEXT_CY = CY
      ),
    by = 'N',
    relationship = 'many-to-many'
  ) |>
  dplyr::filter(
    (TAKE & (D == NEXT_D)) | !TAKE
  ) |>
  dplyr::rowwise() |>
  dplyr::transmute(
    ELEMENT =
      list(
        shiny::tags$line(
          x1 = CX,
          x2 = NEXT_CX,
          y1 = CY,
          y2 = NEXT_CY,
          stroke = dplyr::case_when(TAKE ~ 'black', TRUE ~ 'grey'),
          `stroke-width` = dplyr::case_when(TAKE ~ '3px', TRUE ~ '1px')
        )
      )
  )

diceRolls <-
  nodes |>
  dplyr::distinct(D, CY) |>
  dplyr::mutate(
    X = 50.0,
    Y = CY - radius - 5.0,
    HEIGHT = 2.0 * (radius + 5.0),
    WIDTH = max(nodes$CX) - min(nodes$CX) + 100.0
  ) |>
  dplyr::rowwise() |>
  dplyr::mutate(
    TEXT =
      list(shiny::tags$text(D, x = 65.0, y = CY)),
    RECT =
      list(
        shiny::tags$rect(
          x = X,
          y = Y,
          width = WIDTH,
          height = HEIGHT,
          fill = '#f0e1f7'
        )
      )
  ) |>
  dplyr::ungroup()

turns <-
  nodes |>
  dplyr::group_by(N, CX) |>
  dplyr::summarise(MIN_CY = min(CY), .groups = 'drop') |>
  dplyr::rowwise() |>
  dplyr::mutate(
    TEXT =
      list(
        shiny::tags$text(
          dplyr::case_match(N, 0L ~ 'START', .default = as.character(N)),
          x = CX,
          y = 50.0
        )
      ),
    LINE =
      list(
        shiny::tags$line(
          x1 = CX,
          x2 = CX,
          y1 = 60.0,
          y2 = MIN_CY,
          `stroke-dasharray` = '2 2',
          stroke = 'black'
        )
      )
  ) |>
  dplyr::ungroup()

diceAxisTitle <-
  local({
    x <- 25.0
    y <-
      nodes |>
      dplyr::pull(CY) |>
      unique() |>
      mean()
    
    shiny::tags$text(
      'DICE ROLL',
      `font-weight` = 'bold',
      transform =
        glue::glue('translate({x}, {y}) rotate(-90)')
    )
  })

turnAxisTitle <-
  shiny::tags$text(
    'TURN',
    x =
      nodes |>
      dplyr::pull(CX) |>
      unique() |>
      mean(),
    y = 25.0,
    `font-weight` = 'bold'
  )

shiny::tags$svg(
  style,
  diceRolls$RECT,
  turns$LINE,
  lines$ELEMENT,
  nodes$NODE,
  nodes$PROB_FILL,
  nodes$VALUE_ROLL,
  nodes$VALUE_TAKE,
  diceRolls$TEXT,
  turns$TEXT,
  diceAxisTitle,
  turnAxisTitle,
  viewbox =
    glue::glue('0 0 {max(nodes$CX) + margin$X} {max(nodes$CY) + margin$Y - 50.0}')
)
```

We are now ready to consider the full puzzle specification.

### Proposed Solution (Original Puzzle) {.tabset}

```{r processVariant1}
variant1Analysis <-
  xfun::cache_rds(
    expr = { fnPartIResults(Dmax, Nmax) },
    hash =
      list(
        Dmax,
        Nmax,
        fs::file_info('SCRIPTS/PART_1.R')$modification_time
      ),
    dir = 'cache/'
  )
```

Here we consider the `r Dmax` sided die across `r Nmax` turns.

Due to the number of decision points, we cannot use the same layout as for the toy example above.

However, we can still use the same underlying approach to identify the recommended strategy.

<br/>

#### Strategy

* When the game starts, the player must always roll.
* Should the die show any value on/above 18, the player is recommended to continually take for all remaining turns.
* This also becomes the case for lower die values, once the game progresses.
* These dice rolls effectively become **absorbing states**, albeit after a varying number of passed turns.
* For the last turn, as expected, the player is recommended to take the value regardless as there is no benefit from rolling.

```{r include = TRUE}
fnPlotRecommendedStrategy(variant1Analysis$STRATEGY)
```

#### Visits

-   This clearly highlights that, as turns progress, we are attracted to dice rolls 18, 19 and 20.
-   This is because, once those values are obtained, the strategy dictates that we will repeatedly take those values, with<u>out</u> any rolls.
-   Consequently, the probability of all other dice rolls approaches zero.

```{r include = TRUE}
fnPlotDistributionByTurn(variant1Analysis$CUMULATIVE_PROBS)
```

#### Outcomes

```{r}
variant1Expected <-
  variant1Analysis$CUMULATIVE_PROBS |>
  dplyr::slice_max(order_by = N) |>
  dplyr::summarise(
    EXPECTED = sum(PROB * VALUE)
  ) |>
  dplyr::pull(EXPECTED)
```

-   The maximum possible score is `r Dmax` x `r Nmax` = `r scales::comma(Nmax * Dmax)`.
-   As a consequence of the strategy, we see that some values are more likely than others; we would expect the more significant spikes to be "near" multiples of 18, 19 and 20.
-   The expected closing score is `r scales::number(variant1Expected, accuracy = 0.1, big.mark = ',')`, as indicated by the vertical [red]{foreground="red"} line.

```{r include = TRUE}
fnPlotDistributionClosingScores(variant1Analysis$CUMULATIVE_PROBS) +
  geom_vline(xintercept = variant1Expected, color = 'red')
```

## Second Variant

The rules are as for the first variant above, but with the following differences:

-   Any time the player chooses to bank the current value, the next turn (assuming turns remaining), must be a roll of the die.
-   Unlike the decision to bank, there is no limit to consecutive rolls.

For example, the player could roll, bank, roll, roll, bank, etc...

### Proposed Solution (Toy Example)

Revisiting the same toy example as before, we now observe the following.

* Note that the layout is different as the available action at a given node depends on what action was taken for the <u>previous</u> turn; specifically, if a value was taken during the previous turn, the player **must** roll for the current turn.
* For nodes where a roll can is taken ([**red**]{foreground="red"} outline), lines connect to those nodes for the next turn which have the highest expected value for each respective dice roll.
* For nodes where the value is taken ([**blue**]{foreground="blue"} outline), the node is directly linked (via **thick black** line) to the corresponding roll for that same die value at the next turn.

```{r part2ToyExample, local = TRUE, results = 'asis', include = TRUE}
exampleResults <-
  fnPartIIResults(Dmax = 4L, Nmax = 6L)

margin <-
  list(X = 50.0, Y = 100.0)

radius <- 17.0

style <-
  local({
    nodestyle <-
      htmltools::css(
        `stroke-width` = '2px',
        fill = 'white'
      )

    textStyle <-
      htmltools::css(
        `text-anchor` = 'middle',
        `alignment-baseline` = 'middle'
      )

    shiny::tags$style(
      glue::glue(
        'circle {<nodestyle>} text {<textStyle>}',
        .open = '<',
        .close = '>'
      )
    )
  })

nodes <-
  exampleResults$OUTCOMES |>
  dplyr::mutate(
    CX = 2.0 * margin$X + N * 125.0,
    CY = margin$Y + (D - 1.0) * 100.0 + TAKE * 40.0
  ) |>
  dplyr::rowwise() |>
  dplyr::mutate(
    NODE =
      list(
        shiny::tags$circle(
          cx = CX,
          cy = CY,
          r = radius,
          stroke =
            dplyr::if_else(TAKE, 'blue', 'red')
        )
      ),
    VALUE_TEXT =
      list(
        shiny::tags$text(
          scales::number(VALUE, accuracy = 0.1),
          `font-size` = '75%',
          x = CX,
          y = CY
        )
      )
  ) |>
  dplyr::ungroup()

lines <-
  nodes |>
  dplyr::select(N, D, TAKE, CX, CY) |>
  dplyr::inner_join(
    nodes |>
      dplyr::transmute(
        NEXT_N = N,
        NEXT_D = D,
        N = NEXT_N - 1L,
        NEXT_CX = CX,
        NEXT_CY = CY,
        NEXT_TAKE = TAKE,
        NEXT_VALUE = VALUE
      ),
    by = 'N',
    relationship = 'many-to-many'
  ) |>
  dplyr::arrange(
    N,
    D,
    # Prioritise TAKEs.
    !TAKE
  ) |>
  dplyr::filter(
    (TAKE & (!NEXT_TAKE) & (D == NEXT_D)) | !TAKE
  ) |>
  dplyr::slice_max(order_by = NEXT_VALUE, by = c('N', 'D', 'TAKE', 'NEXT_D')) |>
  dplyr::rowwise() |>
  dplyr::transmute(
    ELEMENT =
      list(
        shiny::tags$line(
          x1 = CX,
          x2 = NEXT_CX,
          y1 = CY,
          y2 = NEXT_CY,
          stroke = dplyr::if_else(TAKE, 'black', 'grey'),
          `stroke-width` = dplyr::if_else(TAKE, '3px', '1px')
        )
      )
  )

diceRolls <-
  nodes |>
  dplyr::group_by(D) |>
  dplyr::summarise(
    X = 50.0,
    Y = min(CY) - radius - 5.0,
    YMID = (min(CY) + max(CY)) / 2.0,
    HEIGHT = max(CY) + radius + 5.0 - Y,
    WIDTH = max(nodes$CX) - min(nodes$CX) + 100.0,
    .groups = 'drop'
  ) |>
  dplyr::rowwise() |>
  dplyr::mutate(
    TEXT =
      list(shiny::tags$text(D, x = 65.0, y = YMID)),
    RECT =
      list(
        shiny::tags$rect(
          x = X,
          y = Y,
          width = WIDTH,
          height = HEIGHT,
          fill = '#f0e1f7'
        )
      )
  ) |>
  dplyr::ungroup()

turns <-
  nodes |>
  dplyr::group_by(N, CX) |>
  dplyr::summarise(MIN_CY = min(CY), .groups = 'drop') |>
  dplyr::rowwise() |>
  dplyr::mutate(
    TEXT =
      list(
        shiny::tags$text(
          dplyr::case_match(N, 0L ~ 'START', .default = as.character(N)),
          x = CX,
          y = 50.0
        )
      ),
    LINE =
      list(
        shiny::tags$line(
          x1 = CX,
          x2 = CX,
          y1 = 60.0,
          y2 = MIN_CY,
          `stroke-dasharray` = '2 2',
          stroke = 'black'
        )
      )
  ) |>
  dplyr::ungroup()

diceAxisTitle <-
  local({
    x <- 25.0
    y <-
      nodes |>
      dplyr::pull(CY) |>
      unique() |>
      mean()

    shiny::tags$text(
      'DICE ROLL',
      `font-weight` = 'bold',
      transform =
        glue::glue('translate({x}, {y}) rotate(-90)')
    )
  })

turnAxisTitle <-
  shiny::tags$text(
    'TURN',
    x =
      nodes |>
      dplyr::pull(CX) |>
      unique() |>
      mean(),
    y = 25.0,
    `font-weight` = 'bold'
  )

shiny::tags$svg(
  style,
  diceRolls$RECT,
  turns$LINE,
  lines$ELEMENT,
  nodes$NODE,
  nodes$VALUE_TEXT,
  diceRolls$TEXT,
  turns$TEXT,
  diceAxisTitle,
  turnAxisTitle,
  viewbox =
    glue::glue('0 0 {max(nodes$CX) + margin$X} {max(nodes$CY) + margin$Y - 50.0}')
)
```

We notice that for the opening turn, under the desire to maximize the expected pay-off, we should take the opening value of 1.

We are now ready to consider the full puzzle specification.

### Proposed Solution (Original Puzzle) {.tabset}

```{r processVariant2}
variant2Analysis <-
  xfun::cache_rds(
    expr = { fnPartIIResults(Dmax, Nmax) },
    hash =
      list(
        Dmax,
        Nmax,
        fs::file_info('SCRIPTS/PART_2.R')$modification_time
      ),
    dir = 'cache/'
  )
```

#### Strategy

```{r fig.height = 8, include = TRUE}
variant2Analysis$STRATEGY |>
  dplyr::filter(N > 0L) |>
  fnPlotRecommendedStrategy(
    title =
      'Recommended strategy by turn, dice roll and prior action.'
  ) +
  facet_grid(
    PRIOR_TAKE ~ .,
    labeller =
      labeller(
        PRIOR_TAKE =
          c(`FALSE` = 'PRIOR WAS ROLL', `TRUE` = 'PRIOR WAS TAKE')
      )
  )
```

#### Visits

```{r include = TRUE}
fnPlotDistributionByTurn(variant2Analysis$CUMULATIVE_PROBS)
```

#### Outcomes


